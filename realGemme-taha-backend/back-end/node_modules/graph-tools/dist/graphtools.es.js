import { isEmpty, union } from 'lodash';

function components(g) {
    var visited = {};
    var cmpt = [];
    var cmpts = [];
    function dfs(v) {
        if (Reflect.has(visited, v)) {
            return;
        }
        visited[v] = true;
        cmpt.push(v);
        var succ = g.successors(v);
        if (succ !== undefined) {
            succ.forEach(dfs);
        }
        var pred = g.predecessors(v);
        if (pred !== undefined) {
            pred.forEach(dfs);
        }
    }
    g.nodes().forEach(function (v) {
        cmpt = [];
        dfs(v);
        if (cmpt.length) {
            cmpts.push(cmpt);
        }
    });
    return cmpts;
}

var Order;
(function (Order) {
    Order["pre"] = "pre";
    Order["post"] = "post";
})(Order || (Order = {}));
function dfs(g, vs, order) {
    if (!Array.isArray(vs)) {
        vs = [vs];
    }
    var navigation = (g.directed ? g.successors : g.neighbors).bind(g);
    var acc = [];
    var visited = {};
    vs.forEach(function (v) {
        if (!g.hasNode(v)) {
            throw new Error("Graph does not have node: " + v);
        }
        doDfs(g, v, (order === "post"), visited, navigation, acc);
    });
    return acc;
}
function doDfs(g, v, postOrder, visited, navigation, acc) {
    if (!Reflect.has(visited, v)) {
        visited[v] = true;
        if (!postOrder) {
            acc.push(v);
        }
        navigation(v).forEach(function (w) {
            doDfs(g, w, postOrder, visited, navigation, acc);
        });
        if (postOrder) {
            acc.push(v);
        }
    }
}

var PriorityQueue = (function () {
    function PriorityQueue() {
        this.keyIndices = {};
        this.arr = [];
        this.keyIndices = {};
    }
    PriorityQueue.prototype.size = function () {
        return this.arr.length;
    };
    PriorityQueue.prototype.keys = function () {
        return this.arr.map(function (x) { return x.key; });
    };
    PriorityQueue.prototype.has = function (key) {
        return Reflect.has(this.keyIndices, key);
    };
    PriorityQueue.prototype.priority = function (key) {
        var index = this.keyIndices[key];
        if (index !== undefined) {
            return this.arr[index].priority;
        }
    };
    PriorityQueue.prototype.min = function () {
        if (this.size() === 0) {
            throw new Error("Queue underflow");
        }
        return this.arr[0].key;
    };
    PriorityQueue.prototype.add = function (key, priority) {
        key = String(key);
        if (!Reflect.has(this.keyIndices, key)) {
            var index = this.size();
            this.keyIndices[key] = index;
            this.arr.push({ key: key, priority: priority });
            this._decrease(index);
            return true;
        }
        return false;
    };
    PriorityQueue.prototype.removeMin = function () {
        if (this.size() === 0) {
            throw new Error("Queue underflow");
        }
        this._swap(0, this.size() - 1);
        var min = this.arr.pop();
        if (min) {
            delete this.keyIndices[min.key];
            this._heapify(0);
            return min.key;
        }
    };
    PriorityQueue.prototype.decrease = function (key, priority) {
        var index = this.keyIndices[key];
        if (priority > this.arr[index].priority) {
            throw new Error("New priority is greater than current priority. " +
                "Key: " + key + " Old: " + this.arr[index].priority + " New: " + priority);
        }
        this.arr[index].priority = priority;
        this._decrease(index);
    };
    PriorityQueue.prototype._heapify = function (i) {
        var arr = this.arr;
        var l = 2 * i;
        var r = l + 1;
        var largest = i;
        if (l < arr.length) {
            largest = arr[l].priority < arr[largest].priority ? l : largest;
            if (r < arr.length) {
                largest = arr[r].priority < arr[largest].priority ? r : largest;
            }
            if (largest !== i) {
                this._swap(i, largest);
                this._heapify(largest);
            }
        }
    };
    PriorityQueue.prototype._decrease = function (index) {
        var arr = this.arr;
        var priority = arr[index].priority;
        var parent;
        while (index !== 0) {
            parent = Math.floor(index / 2);
            if (arr[parent].priority < priority) {
                break;
            }
            this._swap(index, parent);
            index = parent;
        }
    };
    PriorityQueue.prototype._swap = function (i, j) {
        var arr = this.arr;
        var keyIndices = this.keyIndices;
        var origArrI = arr[i];
        var origArrJ = arr[j];
        arr[i] = origArrJ;
        arr[j] = origArrI;
        keyIndices[origArrJ.key] = i;
        keyIndices[origArrI.key] = j;
    };
    return PriorityQueue;
}());

var DEFAULT_WEIGHT_FUNC = function () { return 1; };
function dijkstra(g, source, weightFn, edgeFn) {
    if (weightFn === void 0) { weightFn = DEFAULT_WEIGHT_FUNC; }
    if (edgeFn === void 0) { edgeFn = (function (v) { return g.outEdges(v); }); }
    return runDijkstra(g, String(source), weightFn, edgeFn);
}
function runDijkstra(g, source, weightFn, edgeFn) {
    var results = {};
    var pq = new PriorityQueue();
    var v = "";
    var vEntry = { distance: 0 };
    var updateNeighbors = function (edge) {
        var w = edge.v !== v ? edge.v : edge.w;
        var wEntry = results[w];
        var weight = weightFn(edge);
        var distance = vEntry.distance + weight;
        if (weight < 0) {
            throw new Error("dijkstra does not allow negative edge weights. " +
                "Bad edge: " + edge + " Weight: " + weight);
        }
        if (distance < wEntry.distance) {
            wEntry.distance = distance;
            wEntry.predecessor = v;
            pq.decrease(w, distance);
        }
    };
    g.nodes().forEach(function (v2) {
        var distance2 = v2 === source ? 0 : Number.POSITIVE_INFINITY;
        results[v2] = { distance: distance2 };
        pq.add(v2, distance2);
    });
    while (pq.size() > 0) {
        v = pq.removeMin();
        vEntry = results[v];
        if (vEntry.distance === Number.POSITIVE_INFINITY) {
            break;
        }
        var res = edgeFn(v);
        if (res !== undefined) {
            res.forEach(updateNeighbors);
        }
    }
    return results;
}
function dijkstraAll(g, weightFn, edgeFn) {
    var res = {};
    g.nodes().forEach(function (v) {
        res[v] = dijkstra(g, v, weightFn, edgeFn);
    });
    return res;
}

function tarjan(g) {
    var index = 0;
    var stack = [];
    var visited = {};
    var results = [];
    function dfs(v) {
        var entry = visited[v] = {
            lowLink: index,
            index: index++,
            onStack: true,
        };
        stack.push(v);
        var succ = g.successors(v);
        if (succ !== undefined) {
            succ.forEach(function (w) {
                if (!Reflect.has(visited, w)) {
                    dfs(w);
                    entry.lowLink = Math.min(entry.lowLink, visited[w].lowLink);
                }
                else if (visited[w].onStack) {
                    entry.lowLink = Math.min(entry.lowLink, visited[w].index);
                }
            });
        }
        if (entry.lowLink === entry.index) {
            var cmpt = [];
            var w = void 0;
            do {
                w = String(stack.pop());
                visited[w].onStack = false;
                cmpt.push(w);
            } while (v !== w);
            results.push(cmpt);
        }
    }
    g.nodes().forEach(function (v) {
        if (!Reflect.has(visited, v)) {
            dfs(v);
        }
    });
    return results;
}

function findCycles(g) {
    return tarjan(g).filter(function (cmpt) {
        return cmpt.length > 1 || (cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]));
    });
}

var DEFAULT_WEIGHT_FUNC$1 = function () { return 1; };
function floydWarshall(g, weightFn, edgeFn) {
    return runFloydWarshall(g, weightFn, edgeFn);
}
function runFloydWarshall(g, weightFn, edgeFn) {
    if (weightFn === void 0) { weightFn = DEFAULT_WEIGHT_FUNC$1; }
    if (edgeFn === void 0) { edgeFn = function (v) { return g.outEdges(v); }; }
    var results = {};
    var nodes = g.nodes();
    nodes.forEach(function (v) {
        results[v] = {};
        results[v][v] = { distance: 0 };
        nodes.forEach(function (w) {
            if (v !== w) {
                results[v][w] = { distance: Number.POSITIVE_INFINITY };
            }
        });
        var res = edgeFn(v);
        if (res !== undefined) {
            res.forEach(function (edge) {
                var w = edge.v === v ? edge.w : edge.v;
                var d = weightFn(edge);
                results[v][w] = { distance: d, predecessor: v };
            });
        }
    });
    nodes.forEach(function (k) {
        var rowK = results[k];
        nodes.forEach(function (i) {
            var rowI = results[i];
            nodes.forEach(function (j) {
                var ik = rowI[k];
                var kj = rowK[j];
                var ij = rowI[j];
                var altDistance = ik.distance + kj.distance;
                if (altDistance < ij.distance) {
                    ij.distance = altDistance;
                    ij.predecessor = kj.predecessor;
                }
            });
        });
    });
    return results;
}

var CycleException = (function () {
    function CycleException() {
    }
    return CycleException;
}());
function topsort(g) {
    var visited = {};
    var stack = {};
    var results = [];
    function visit(node) {
        if (Reflect.has(stack, node)) {
            throw new CycleException();
        }
        if (!Reflect.has(visited, node)) {
            stack[node] = true;
            visited[node] = true;
            var pred = g.predecessors(node);
            if (pred !== undefined) {
                pred.forEach(visit);
            }
            delete stack[node];
            results.push(node);
        }
    }
    g.sinks().forEach(visit);
    if (Object.keys(visited).length !== g.nodeCount()) {
        throw new CycleException();
    }
    return results;
}

function isAcyclic(g) {
    try {
        topsort(g);
    }
    catch (e) {
        if (e instanceof CycleException) {
            return false;
        }
        throw e;
    }
    return true;
}

function postorder(g, vs) {
    return dfs(g, vs, Order.post);
}

function preorder(g, vs) {
    return dfs(g, vs, Order.pre);
}

var DEFAULT_EDGE_NAME = "\x00";
var GRAPH_NODE = "\x00";
var EDGE_KEY_DELIM = "\x01";
var Graph = (function () {
    function Graph(opt) {
        this.nodesObj = {};
        this.parentObj = {};
        this.childrenObj = {};
        this.in = {};
        this.preds = {};
        this.out = {};
        this.sucs = {};
        this.edgeObjs = {};
        this.edgeLabels = {};
        this.nodeCountNumber = 0;
        this.edgeCountNumber = 0;
        this.defaultNodeLabelFn = function (label) { return undefined; };
        this.defaultEdgeLabelFn = function (label) { return undefined; };
        this.directed = (opt && opt.directed !== undefined) ? opt.directed : true;
        this.multigraph = (opt && opt.multigraph !== undefined) ? opt.multigraph : false;
        this.compound = (opt && opt.compound !== undefined) ? opt.compound : false;
        if (this.compound) {
            this.childrenObj[GRAPH_NODE] = {};
        }
    }
    Graph.prototype.setGraph = function (label) {
        this.label = label;
        return this;
    };
    Graph.prototype.graph = function () {
        return this.label;
    };
    Graph.prototype.setDefaultNodeLabel = function (newDefault) {
        if (typeof newDefault !== "function") {
            this.defaultNodeLabelFn = function () { return newDefault; };
            return this;
        }
        this.defaultNodeLabelFn = newDefault;
        return this;
    };
    Graph.prototype.nodeCount = function () {
        return this.nodeCountNumber;
    };
    Graph.prototype.nodes = function () {
        return Object.keys(this.nodesObj);
    };
    Graph.prototype.sources = function () {
        var _this = this;
        return this.nodes().filter(function (v) { return isEmpty(_this.in[v]); });
    };
    Graph.prototype.sinks = function () {
        var _this = this;
        return this.nodes().filter(function (v) { return isEmpty(_this.out[v]); });
    };
    Graph.prototype.setNodes = function (vs, value) {
        var _this = this;
        var args = arguments;
        vs.forEach(function (v) {
            if (args.length > 1) {
                _this.setNode(v, value);
            }
            else {
                _this.setNode(v);
            }
        });
        return this;
    };
    Graph.prototype.setNode = function (v, value) {
        if (this.hasNode(v)) {
            if (arguments.length > 1) {
                this.nodesObj[v] = value;
            }
            return this;
        }
        this.nodesObj[v] = arguments.length > 1 ? value : this.defaultNodeLabelFn(v);
        if (this.compound) {
            this.parentObj[v] = GRAPH_NODE;
            this.childrenObj[v] = {};
            this.childrenObj[GRAPH_NODE][v] = true;
        }
        this.in[v] = {};
        this.preds[v] = {};
        this.out[v] = {};
        this.sucs[v] = {};
        ++this.nodeCountNumber;
        return this;
    };
    Graph.prototype.node = function (v) {
        return this.nodesObj[v];
    };
    Graph.prototype.hasNode = function (v) {
        return Reflect.has(this.nodesObj, v);
    };
    Graph.prototype.removeNode = function (v) {
        var _this = this;
        if (this.hasNode(v)) {
            var removeEdge = function (e) { _this.removeEdge(_this.edgeObjs[e]); };
            delete this.nodesObj[v];
            if (this.compound) {
                this.removeFromParentsChildList(v);
                delete this.parentObj[v];
                var children = this.children(v);
                if (children !== undefined) {
                    children.forEach(function (child) { return _this.setParent(child); });
                }
                delete this.childrenObj[v];
            }
            Object.keys(this.in[v]).forEach(removeEdge);
            delete this.in[v];
            delete this.preds[v];
            Object.keys(this.out[v]).forEach(removeEdge);
            delete this.out[v];
            delete this.sucs[v];
            --this.nodeCountNumber;
        }
        return this;
    };
    Graph.prototype.setParent = function (v, parent) {
        if (!this.compound) {
            throw new Error("Cannot set parent in a non-compound graph");
        }
        if (parent === undefined) {
            parent = GRAPH_NODE;
        }
        else {
            parent += "";
            for (var ancestor = parent; ancestor !== undefined; ancestor = this.parent(ancestor)) {
                if (ancestor === v) {
                    throw new Error("Setting " + parent + " as parent of " + v + " would create a cycle");
                }
            }
            this.setNode(parent);
        }
        this.setNode(v);
        this.removeFromParentsChildList(v);
        this.parentObj[v] = parent;
        this.childrenObj[parent][v] = true;
        return this;
    };
    Graph.prototype.removeFromParentsChildList = function (v) {
        delete this.childrenObj[this.parentObj[v]][v];
    };
    Graph.prototype.parent = function (v) {
        if (this.compound) {
            var parent = this.parentObj[v];
            if (parent !== GRAPH_NODE) {
                return parent;
            }
        }
    };
    Graph.prototype.children = function (v) {
        if (v === void 0) { v = GRAPH_NODE; }
        if (this.compound) {
            var children = this.childrenObj[v];
            if (children) {
                return Object.keys(children);
            }
        }
        else if (v === GRAPH_NODE) {
            return this.nodes();
        }
        else if (this.hasNode(v)) {
            return [];
        }
        return undefined;
    };
    Graph.prototype.predecessors = function (v) {
        var predsV = this.preds[v];
        if (predsV) {
            return Object.keys(predsV);
        }
        return undefined;
    };
    Graph.prototype.successors = function (v) {
        var sucsV = this.sucs[v];
        if (sucsV) {
            return Object.keys(sucsV);
        }
        return undefined;
    };
    Graph.prototype.neighbors = function (v) {
        var preds = this.predecessors(v);
        var sucs = this.successors(v);
        if (preds) {
            return union(preds, sucs);
        }
        return undefined;
    };
    Graph.prototype.isLeaf = function (v) {
        var neighbors;
        if (this.directed) {
            neighbors = this.successors(v);
        }
        else {
            neighbors = this.neighbors(v);
        }
        if (neighbors) {
            return neighbors.length === 0;
        }
        return false;
    };
    Graph.prototype.filterNodes = function (filter) {
        var copy = new Graph({
            compound: this.compound,
            directed: this.directed,
            multigraph: this.multigraph,
        });
        copy.setGraph(this.graph());
        for (var _i = 0, _a = Object.entries(this.nodesObj); _i < _a.length; _i++) {
            var _b = _a[_i], v = _b[0], value = _b[1];
            if (filter(v)) {
                copy.setNode(v, value);
            }
        }
        for (var _c = 0, _d = Object.entries(this.edgeObjs); _c < _d.length; _c++) {
            var _e = _d[_c], v = _e[0], edgeObject = _e[1];
            if (copy.hasNode(edgeObject.v) && copy.hasNode(edgeObject.w)) {
                copy.setEdge(edgeObject, this.edge(edgeObject));
            }
        }
        var self = this;
        var parents = {};
        function findParent(v) {
            var parent = self.parent(v);
            if (parent === undefined || copy.hasNode(parent)) {
                parents[v] = parent;
                return parent;
            }
            else if (parent in parents) {
                return parents[parent];
            }
            else {
                return findParent(parent);
            }
        }
        if (this.compound) {
            copy.nodes().forEach(function (v) { return copy.setParent(v, findParent(v)); });
        }
        return copy;
    };
    Graph.prototype.setDefaultEdgeLabel = function (newDefault) {
        if (typeof newDefault !== "function") {
            this.defaultEdgeLabelFn = function () { return newDefault; };
        }
        else {
            this.defaultEdgeLabelFn = newDefault;
        }
        return this;
    };
    Graph.prototype.edgeCount = function () {
        return this.edgeCountNumber;
    };
    Graph.prototype.edges = function () {
        return Object.values(this.edgeObjs);
    };
    Graph.prototype.setPath = function (vs, value) {
        var _this = this;
        var args = arguments;
        vs.reduce(function (v, w) {
            if (args.length > 1) {
                _this.setEdge(v, w, value);
            }
            else {
                _this.setEdge(v, w);
            }
            return w;
        });
        return this;
    };
    Graph.prototype.setEdge = function (x) {
        var v;
        var w;
        var name;
        var value;
        var valueSpecified = false;
        var arg0 = arguments[0];
        if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
            v = arg0.v;
            w = arg0.w;
            name = arg0.name;
            if (arguments.length === 2) {
                value = arguments[1];
                valueSpecified = true;
            }
        }
        else {
            v = arg0;
            w = arguments[1];
            name = arguments[3];
            if (arguments.length > 2) {
                value = arguments[2];
                valueSpecified = true;
            }
        }
        v = "" + v;
        w = "" + w;
        if (name !== undefined) {
            name = "" + name;
        }
        var e = edgeArgsToId(this.directed, v, w, name);
        if (Reflect.has(this.edgeLabels, e)) {
            if (valueSpecified) {
                this.edgeLabels[e] = value;
            }
            return this;
        }
        if (name !== undefined && !this.multigraph) {
            throw new Error("Cannot set a named edge when isMultigraph = false");
        }
        this.setNode(v);
        this.setNode(w);
        this.edgeLabels[e] = valueSpecified ? value : this.defaultEdgeLabelFn(v, w, name);
        var edgeObj = edgeArgsToObj(this.directed, v, w, name);
        v = edgeObj.v;
        w = edgeObj.w;
        Object.freeze(edgeObj);
        this.edgeObjs[e] = edgeObj;
        incrementOrInitEntry(this.preds[w], v);
        incrementOrInitEntry(this.sucs[v], w);
        this.in[w][e] = edgeObj;
        this.out[v][e] = edgeObj;
        this.edgeCountNumber++;
        return this;
    };
    Graph.prototype.edge = function (v) {
        var e = arguments.length === 1
            ? edgeObjToId(this.directed, arguments[0])
            : edgeArgsToId(this.directed, v, arguments[1], arguments[2]);
        return this.edgeLabels[e];
    };
    Graph.prototype.hasEdge = function (v) {
        var e = arguments.length === 1
            ? edgeObjToId(this.directed, arguments[0])
            : edgeArgsToId(this.directed, v, arguments[1], arguments[2]);
        return Reflect.has(this.edgeLabels, e);
    };
    Graph.prototype.removeEdge = function (v) {
        var e = arguments.length === 1
            ? edgeObjToId(this.directed, arguments[0])
            : edgeArgsToId(this.directed, v, arguments[1], arguments[2]);
        var edge = this.edgeObjs[e];
        if (edge) {
            var v1 = edge.v;
            var w1 = edge.w;
            delete this.edgeLabels[e];
            delete this.edgeObjs[e];
            decrementOrRemoveEntry(this.preds[w1], v1);
            decrementOrRemoveEntry(this.sucs[v1], w1);
            delete this.in[w1][e];
            delete this.out[v1][e];
            this.edgeCountNumber--;
        }
        return this;
    };
    Graph.prototype.inEdges = function (v, u) {
        var inV = this.in[v];
        if (inV) {
            var edges = Object.values(inV);
            if (!u) {
                return edges;
            }
            return edges.filter(function (edge) { return edge.v === u; });
        }
        return undefined;
    };
    Graph.prototype.outEdges = function (v, w) {
        var outV = this.out[v];
        if (outV) {
            var edges = Object.values(outV);
            if (!w) {
                return edges;
            }
            return edges.filter(function (edge) { return edge.w === w; });
        }
        return undefined;
    };
    Graph.prototype.nodeEdges = function (v, w) {
        var inEdges = this.inEdges(v, w);
        var outEdges = this.outEdges(v, w);
        if (inEdges && outEdges) {
            return inEdges.concat(outEdges);
        }
        return undefined;
    };
    return Graph;
}());
function incrementOrInitEntry(map, k) {
    if (map[k]) {
        map[k]++;
    }
    else {
        map[k] = 1;
    }
}
function decrementOrRemoveEntry(map, k) {
    if (!--map[k]) {
        delete map[k];
    }
}
function edgeArgsToId(isDirected, v0, w0, name) {
    var v = "" + v0;
    var w = "" + w0;
    if (!isDirected && v > w) {
        var tmp = v;
        v = w;
        w = tmp;
    }
    return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM + (name === undefined ? DEFAULT_EDGE_NAME : name);
}
function edgeArgsToObj(isDirected, v0, w0, name) {
    var v = "" + v0;
    var w = "" + w0;
    if (!isDirected && v > w) {
        var tmp = v;
        v = w;
        w = tmp;
    }
    var edgeObj = { v: v, w: w };
    if (name) {
        edgeObj.name = name;
    }
    return edgeObj;
}
function edgeObjToId(isDirected, edgeObj) {
    return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
}

function prim(g, weightFunc) {
    var result = new Graph();
    var parents = {};
    var pq = new PriorityQueue();
    var v;
    function updateNeighbors(edge) {
        var w = edge.v === v ? edge.w : edge.v;
        var pri = pq.priority(w);
        if (pri !== undefined) {
            var edgeWeight = weightFunc(edge);
            if (edgeWeight < pri) {
                parents[w] = v;
                pq.decrease(w, edgeWeight);
            }
        }
    }
    if (g.nodeCount() === 0) {
        return result;
    }
    g.nodes().forEach(function (v2) {
        pq.add(v2, Number.POSITIVE_INFINITY);
        result.setNode(v2);
    });
    pq.decrease(g.nodes()[0], 0);
    var init = false;
    while (pq.size() > 0) {
        v = String(pq.removeMin());
        if (Reflect.has(parents, v)) {
            result.setEdge(v, parents[v]);
        }
        else if (init) {
            throw new Error("Input graph is not connected: " + g);
        }
        else {
            init = true;
        }
        var nodeEdges = g.nodeEdges(v);
        if (nodeEdges !== undefined) {
            nodeEdges.forEach(updateNeighbors);
        }
    }
    return result;
}

var alg = {
    components: components,
    dfs: dfs,
    dijkstra: dijkstra,
    dijkstraAll: dijkstraAll,
    findCycles: findCycles,
    floydWarshall: floydWarshall,
    isAcyclic: isAcyclic,
    postorder: postorder,
    preorder: preorder,
    prim: prim,
    tarjan: tarjan,
    topsort: topsort,
};

function write(g) {
    var jsonObj = {
        edges: writeEdges(g),
        nodes: writeNodes(g),
        options: {
            compound: g.compound,
            directed: g.directed,
            multigraph: g.multigraph,
        },
        value: typeof g.graph === "object" ? Object.assign({}, g.graph()) : g.graph(),
    };
    return jsonObj;
}
function writeNodes(g) {
    return g.nodes().map(function (v) {
        var nodeValue = g.node(v);
        var parent = g.parent(v);
        var node = { v: v, value: undefined, parent: undefined };
        if (nodeValue !== undefined) {
            node.value = nodeValue;
        }
        if (parent !== undefined) {
            node.parent = parent;
        }
        return node;
    });
}
function writeEdges(g) {
    return g.edges().map(function (e) {
        var edgeValue = g.edge(e);
        var edge = {
            name: undefined,
            v: e.v,
            value: undefined,
            w: e.w,
        };
        if (e.name !== undefined) {
            edge.name = e.name;
        }
        if (edgeValue !== undefined) {
            edge.value = edgeValue;
        }
        return edge;
    });
}
function read(jsonObj) {
    var g = new Graph(jsonObj.options).setGraph(jsonObj.value);
    jsonObj.nodes.forEach(function (entry) {
        g.setNode(entry.v, entry.value);
        if (entry.parent) {
            g.setParent(entry.v, entry.parent);
        }
    });
    jsonObj.edges.forEach(function (entry) {
        g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
    });
    return g;
}
var json = {
    read: read,
    write: write,
};

export { alg, json, Graph };
//# sourceMappingURL=graphtools.es.js.map
