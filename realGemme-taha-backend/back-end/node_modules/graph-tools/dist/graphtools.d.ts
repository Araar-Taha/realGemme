export declare type LabelValue = string | number | boolean | object | undefined;
export declare type KeyValue = string | number;
export declare type NameValue = string | number;
export interface IGraphConstructor {
	directed?: boolean;
	multigraph?: boolean;
	compound?: boolean;
}
export interface IEdgeObj {
	[key: string]: string | undefined;
	v: string;
	w: string;
	name?: string;
}
export declare type IDefaultLabelFn = (v: any) => LabelValue;
export declare class Graph {
	readonly directed: boolean;
	readonly multigraph: boolean;
	readonly compound: boolean;
	private label;
	private nodesObj;
	private parentObj;
	private childrenObj;
	private in;
	private preds;
	private out;
	private sucs;
	private edgeObjs;
	private edgeLabels;
	private nodeCountNumber;
	private edgeCountNumber;
	constructor(opt?: IGraphConstructor);
	setGraph(label: LabelValue): Graph;
	graph(): LabelValue;
	setDefaultNodeLabel(newDefault: LabelValue | IDefaultLabelFn): Graph;
	nodeCount(): number;
	nodes(): string[];
	sources(): string[];
	sinks(): string[];
	setNodes(vs: string[], value?: LabelValue): Graph;
	setNode(v: KeyValue, value?: LabelValue): Graph;
	node(v: KeyValue): LabelValue;
	hasNode(v: KeyValue): boolean;
	removeNode(v: KeyValue): Graph;
	setParent(v: KeyValue, parent?: KeyValue): Graph;
	removeFromParentsChildList(v: KeyValue): void;
	parent(v: KeyValue): KeyValue | undefined;
	children(v?: KeyValue): string[] | undefined;
	predecessors(v: KeyValue): string[] | undefined;
	successors(v: KeyValue): string[] | undefined;
	neighbors(v: KeyValue): string[] | undefined;
	isLeaf(v: KeyValue): boolean;
	filterNodes(filter: (v: string) => boolean): Graph;
	setDefaultEdgeLabel(newDefault: LabelValue | IDefaultLabelFn): this;
	edgeCount(): number;
	edges(): IEdgeObj[];
	setPath(vs: string[], value?: LabelValue): Graph;
	setEdge(edgeobj: IEdgeObj, value?: LabelValue): Graph;
	setEdge(v: KeyValue, w: KeyValue, value?: LabelValue, name?: NameValue): Graph;
	edge(v: KeyValue, w: KeyValue, name?: NameValue): LabelValue;
	edge(edgeObj: IEdgeObj): LabelValue;
	hasEdge(v: KeyValue, w: KeyValue, name?: NameValue): boolean;
	hasEdge(edgeObj: IEdgeObj): boolean;
	removeEdge(v: string, w: string, name?: string): Graph;
	removeEdge(edgeObj: IEdgeObj): Graph;
	inEdges(v: string, u?: string): IEdgeObj[] | undefined;
	outEdges(v: string, w?: string): IEdgeObj[] | undefined;
	nodeEdges(v: string, w?: string): IEdgeObj[] | undefined;
	private defaultNodeLabelFn;
	private defaultEdgeLabelFn;
}
declare enum Order {
	pre = "pre",
	post = "post",
}
export interface IEntry {
	[key: string]: number | string;
	distance: number;
}
export interface IDijkstraResult {
	[v: string]: IEntry;
}
export interface IDijkstraAllResult {
	[v: string]: IDijkstraResult;
}
export interface IResult {
	[v: string]: {
		[v: string]: {
			distance: number;
			predecessor?: string;
		};
	};
}
export declare const alg: {
	components: (g: Graph) => string[][];
	dfs: (g: Graph, vs: string | string[], order: Order) => string[];
	dijkstra: (g: Graph, source: string, weightFn?: (edge: IEdgeObj) => number, edgeFn?: (v: string) => IEdgeObj[] | undefined) => IDijkstraResult;
	dijkstraAll: (g: Graph, weightFn: (edge: IEdgeObj) => number, edgeFn?: ((v: string) => IEdgeObj[] | undefined) | undefined) => IDijkstraAllResult;
	findCycles: (g: Graph) => string[][];
	floydWarshall: (g: Graph, weightFn?: ((edge: IEdgeObj) => number) | undefined, edgeFn?: ((v: string) => IEdgeObj[] | undefined) | undefined) => IResult;
	isAcyclic: (g: Graph) => boolean;
	postorder: (g: Graph, vs: string | string[]) => string[];
	preorder: (g: Graph, vs: string | string[]) => string[];
	prim: (g: Graph, weightFunc: (edge: IEdgeObj) => number) => Graph;
	tarjan: (g: Graph) => string[][];
	topsort: (g: Graph) => string[];
};
export interface INodeObj {
	v: KeyValue;
	value: LabelValue;
	parent: KeyValue | undefined;
}
export interface IEdgeObj {
	v: string;
	w: string;
	name: string | undefined;
	value: LabelValue;
}
export interface IJsonObj {
	options: {
		directed: boolean;
		multigraph: boolean;
		compound: boolean;
	};
	nodes: INodeObj[];
	edges: IEdgeObj[];
	value: LabelValue;
}
export declare const json: {
	read: (jsonObj: IJsonObj) => Graph;
	write: (g: Graph) => IJsonObj;
};
